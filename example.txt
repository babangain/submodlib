6000
[||||||||||||||||||||]100% [Iteration 10 of 10][(2131, 5799.8789716959), (2127, 1.0591498613357544), (4448, 0.5210095643997192), (4689, 0.49319756031036377), (1318, 0.42464905977249146), (1251, 0.3849308490753174), (2540, 0.3685189485549927), (615, 0.284201979637146), (797, 0.2619594931602478), (2299, 0.2584272027015686)]
{"input": "Summarize the following code: function(value, attr, range, model) {\n        if (!_.isString(value) || value.length < range[0] || value.length > range[1]) {\n          return this.format(getMessageKey(this.msgKey, defaultMessages.rangeLength), this.formatLabel(attr, model), range[0], range[1]);\n        }\n      }", "output": "Range length validator Validates that the value has to be a string and equal to or between the two numbers specified"}

{"input": "Summarize the following code: function(value, attr, maxValue, model) {\n        if (!isNumber(value) || value > maxValue) {\n          return this.format(getMessageKey(this.msgKey, defaultMessages.max), this.formatLabel(attr, model), maxValue);\n        }\n      }", "output": "Max validator Validates that the value has to be a number and equal to or less than the max value specified"}

{"input": "Summarize the following code: def draw_status(self, writer, idx):\n        \"\"\"\n        Conditionally draw status bar when output terminal is a tty.\n\n        :param writer: callable writes to output stream, receiving unicode.\n        :param idx: current page position index.\n        :type idx: int\n        \"\"\"\n        if self.term.is_a_tty:\n            writer(self.term.hide_cursor())\n            style = self.screen.style\n            writer(self.term.move(self.term.height - 1))\n            if idx == self.last_page:\n                last_end = u'(END)'\n            else:\n                last_end = u'/{0}'.format(self.last_page)\n            txt = (u'Page {idx}{last_end} - '\n                   u'{q} to quit, [keys: {keyset}]'\n                   .format(idx=style.attr_minor(u'{0}'.format(idx)),\n                           last_end=style.attr_major(last_end),\n                           keyset=style.attr_major('kjfb12-='),\n                           q=style.attr_minor(u'q')))\n            writer(self.term.center(txt).rstrip())", "output": "Conditionally draw status bar when output terminal is a tty.\n\n        :param writer: callable writes to output stream, receiving unicode.\n        :param idx: current page position index.\n        :type idx: int"}

{"input": "Summarize the following code: def register_iq_request_handler(self, type_, payload_cls, cb, *,\n                                    with_send_reply=False):\n        \"\"\"\n        Register a coroutine function or a function returning an awaitable to\n        run when an IQ request is received.\n\n        :param type_: IQ type to react to (must be a request type).\n        :type type_: :class:`~aioxmpp.IQType`\n        :param payload_cls: Payload class to react to (subclass of\n            :class:`~xso.XSO`)\n        :type payload_cls: :class:`~.XMLStreamClass`\n        :param cb: Function or coroutine function to invoke\n        :param with_send_reply: Whether to pass a function to send a reply\n             to `cb` as second argument.\n        :type with_send_reply: :class:`bool`\n        :raises ValueError: if there is already a coroutine registered for this\n                            target\n        :raises ValueError: if `type_` is not a request IQ type\n        :raises ValueError: if `type_` is not a valid\n                            :class:`~.IQType` (and cannot be cast to a\n                            :class:`~.IQType`)\n\n        The callback `cb` will be called whenever an IQ stanza with the given\n        `type_` and payload being an instance of the `payload_cls` is received.\n\n        The callback must either be a coroutine function or otherwise return an\n        awaitable. The awaitable must evaluate to a valid value for the\n        :attr:`.IQ.payload` attribute. That value will be set as the payload\n        attribute value of an IQ response (with type :attr:`~.IQType.RESULT`)\n        which is generated and sent by the stream.\n\n        If the awaitable or the function raises an exception, it will be\n        converted to a :class:`~.stanza.Error` object. That error object is\n        then used as payload for an IQ response (with type\n        :attr:`~.IQType.ERROR`) which is generated and sent by the stream.\n\n        If the exception is a subclass of :class:`aioxmpp.errors.XMPPError`, it\n        is converted to an :class:`~.stanza.Error` instance directly.\n        Otherwise, it is wrapped in a :class:`aioxmpp.XMPPCancelError`\n        with ``undefined-condition``.\n\n        For this to work, `payload_cls` *must* be registered using\n        :meth:`~.IQ.as_payload_class`. Otherwise, the payload will\n        not be recognised by the stream parser and the IQ is automatically\n        responded to with a ``feature-not-implemented`` error.\n\n        .. warning::\n\n            When using a coroutine function for `cb`, there is no guarantee\n            that concurrent IQ handlers and other coroutines will execute in\n            any defined order. This implies that the strong ordering guarantees\n            normally provided by XMPP XML Streams are lost when using coroutine\n            functions for `cb`. For this reason, the use of non-coroutine\n            functions is allowed.\n\n        .. note::\n\n            Using a non-coroutine function for `cb` will generally lead to\n            less readable code. For the sake of readability, it is recommended\n            to prefer coroutine functions when strong ordering guarantees are\n            not needed.\n\n        .. versionadded:: 0.11\n\n            When the argument `with_send_reply` is true `cb` will be\n            called with two arguments: the IQ stanza to handle and a\n            unary function `send_reply(result=None)` that sends a\n            response to the IQ request and prevents that an automatic\n            response is sent. If `result` is an instance of\n            :class:`~aioxmpp.XMPPError` an error result is generated.\n\n            This is useful when the handler function needs to execute\n            actions which happen after the IQ result has been sent,\n            for example, sending other stanzas.\n\n        .. versionchanged:: 0.10\n\n            Accepts an awaitable as last argument in addition to coroutine\n            functions.\n\n            Renamed from :meth:`register_iq_request_coro`.\n\n        .. versionadded:: 0.6\n\n           If the stream is :meth:`stop`\\\\ -ped (only if SM is not enabled) or\n           :meth:`close`\\\\ ed, running IQ response coroutines are\n           :meth:`asyncio.Task.cancel`\\\\ -led.\n\n           To protect against that, fork from your coroutine using\n           :func:`asyncio.ensure_future`.\n\n        .. versionchanged:: 0.7\n\n           The `type_` argument is now supposed to be a :class:`~.IQType`\n           member.\n\n        .. deprecated:: 0.7\n\n           Passing a :class:`str` as `type_` argument is deprecated and will\n           raise a :class:`TypeError` as of the 1.0 release. See the Changelog\n           for :ref:`api-changelog-0.7` for further details on how to upgrade\n           your code efficiently.\n        \"\"\"\n        type_ = self._coerce_enum(type_, structs.IQType)\n        if not type_.is_request:\n            raise ValueError(\n                \"{!r} is not a request IQType\".format(type_)\n            )\n\n        key = type_, payload_cls\n\n        if key in self._iq_request_map:\n            raise ValueError(\"only one listener is allowed per tag\")\n\n        self._iq_request_map[key] = cb, with_send_reply\n        self._logger.debug(\n            \"iq request coroutine registered: type=%r, payload=%r\",\n            type_, payload_cls)", "output": "Register a coroutine function or a function returning an awaitable to\n        run when an IQ request is received.\n\n        :param type_: IQ type to react to (must be a request type).\n        :type type_: :class:`~aioxmpp.IQType`\n        :param payload_cls: Payload class to react to (subclass of\n            :class:`~xso.XSO`)\n        :type payload_cls: :class:`~.XMLStreamClass`\n        :param cb: Function or coroutine function to invoke\n        :param with_send_reply: Whether to pass a function to send a reply\n             to `cb` as second argument.\n        :type with_send_reply: :class:`bool`\n        :raises ValueError: if there is already a coroutine registered for this\n                            target\n        :raises ValueError: if `type_` is not a request IQ type\n        :raises ValueError: if `type_` is not a valid\n                            :class:`~.IQType` (and cannot be cast to a\n                            :class:`~.IQType`)\n\n        The callback `cb` will be called whenever an IQ stanza with the given\n        `type_` and payload being an instance of the `payload_cls` is received.\n\n        The callback must either be a coroutine function or otherwise return an\n        awaitable. The awaitable must evaluate to a valid value for the\n        :attr:`.IQ.payload` attribute. That value will be set as the payload\n        attribute value of an IQ response (with type :attr:`~.IQType.RESULT`)\n        which is generated and sent by the stream.\n\n        If the awaitable or the function raises an exception, it will be\n        converted to a :class:`~.stanza.Error` object. That error object is\n        then used as payload for an IQ response (with type\n        :attr:`~.IQType.ERROR`) which is generated and sent by the stream.\n\n        If the exception is a subclass of :class:`aioxmpp.errors.XMPPError`, it\n        is converted to an :class:`~.stanza.Error` instance directly.\n        Otherwise, it is wrapped in a :class:`aioxmpp.XMPPCancelError`\n        with ``undefined-condition``.\n\n        For this to work, `payload_cls` *must* be registered using\n        :meth:`~.IQ.as_payload_class`. Otherwise, the payload will\n        not be recognised by the stream parser and the IQ is automatically\n        responded to with a ``feature-not-implemented`` error.\n\n        .. warning::\n\n            When using a coroutine function for `cb`, there is no guarantee\n            that concurrent IQ handlers and other coroutines will execute in\n            any defined order. This implies that the strong ordering guarantees\n            normally provided by XMPP XML Streams are lost when using coroutine\n            functions for `cb`. For this reason, the use of non-coroutine\n            functions is allowed.\n\n        .. note::\n\n            Using a non-coroutine function for `cb` will generally lead to\n            less readable code. For the sake of readability, it is recommended\n            to prefer coroutine functions when strong ordering guarantees are\n            not needed.\n\n        .. versionadded:: 0.11\n\n            When the argument `with_send_reply` is true `cb` will be\n            called with two arguments: the IQ stanza to handle and a\n            unary function `send_reply(result=None)` that sends a\n            response to the IQ request and prevents that an automatic\n            response is sent. If `result` is an instance of\n            :class:`~aioxmpp.XMPPError` an error result is generated.\n\n            This is useful when the handler function needs to execute\n            actions which happen after the IQ result has been sent,\n            for example, sending other stanzas.\n\n        .. versionchanged:: 0.10\n\n            Accepts an awaitable as last argument in addition to coroutine\n            functions.\n\n            Renamed from :meth:`register_iq_request_coro`.\n\n        .. versionadded:: 0.6\n\n           If the stream is :meth:`stop`\\\\ -ped (only if SM is not enabled) or\n           :meth:`close`\\\\ ed, running IQ response coroutines are\n           :meth:`asyncio.Task.cancel`\\\\ -led.\n\n           To protect against that, fork from your coroutine using\n           :func:`asyncio.ensure_future`.\n\n        .. versionchanged:: 0.7\n\n           The `type_` argument is now supposed to be a :class:`~.IQType`\n           member.\n\n        .. deprecated:: 0.7\n\n           Passing a :class:`str` as `type_` argument is deprecated and will\n           raise a :class:`TypeError` as of the 1.0 release. See the Changelog\n           for :ref:`api-changelog-0.7` for further details on how to upgrade\n           your code efficiently."}

{"input": "Summarize the following code: public static final BigInteger printPriority(Priority priority)\n   {\n      int result = Priority.MEDIUM;\n\n      if (priority != null)\n      {\n         result = priority.getValue();\n      }\n\n      return (BigInteger.valueOf(result));\n   }", "output": "Print priority.\n\n@param priority Priority instance\n@return priority value"}

{"input": "Summarize the following code: protected void processAssignmentBaseline(Row row)\n   {\n      Integer id = row.getInteger(\"ASSN_UID\");\n      ResourceAssignment assignment = m_assignmentMap.get(id);\n      if (assignment != null)\n      {\n         int index = row.getInt(\"AB_BASE_NUM\");\n\n         assignment.setBaselineStart(index, row.getDate(\"AB_BASE_START\"));\n         assignment.setBaselineFinish(index, row.getDate(\"AB_BASE_FINISH\"));\n         assignment.setBaselineWork(index, row.getDuration(\"AB_BASE_WORK\"));\n         assignment.setBaselineCost(index, row.getCurrency(\"AB_BASE_COST\"));\n      }\n   }", "output": "Read resource assignment baseline values.\n\n@param row result set row"}

{"input": "Summarize the following code: function handleGuardedRoute(activator, instance, instruction) {\n            var resultOrPromise = router.guardRoute(instance, instruction);\n            if (resultOrPromise) {\n                if (resultOrPromise.then) {\n                    resultOrPromise.then(function(result) {\n                        if (result) {\n                            if (system.isString(result)) {\n                                redirect(result);\n                            } else {\n                                activateRoute(activator, instance, instruction);\n                            }\n                        } else {\n                            cancelNavigation(instance, instruction);\n                        }\n                    });\n                } else {\n                    if (system.isString(resultOrPromise)) {\n                        redirect(resultOrPromise);\n                    } else {\n                        activateRoute(activator, instance, instruction);\n                    }\n                }\n            } else {\n                cancelNavigation(instance, instruction);\n            }\n        }", "output": "Inspects routes and modules before activation. Can be used to protect access by cancelling navigation or redirecting.\n@method guardRoute\n@param {object} instance The module instance that is about to be activated by the router.\n@param {object} instruction The route instruction. The instruction object has config, fragment, queryString, params and queryParams properties.\n@return {Promise|Boolean|String} If a boolean, determines whether or not the route should activate or be cancelled. If a string, causes a redirect to the specified route. Can also be a promise for either of these value types."}

{"input": "Summarize the following code: func (s *DirectoryLimits) SetCloudOnlyMicrosoftADLimit(v int64) *DirectoryLimits {\n\ts.CloudOnlyMicrosoftADLimit = &v\n\treturn s\n}", "output": "// SetCloudOnlyMicrosoftADLimit sets the CloudOnlyMicrosoftADLimit field's value."}

{"input": "Summarize the following code: func (s *ListEndpointConfigsOutput) SetEndpointConfigs(v []*EndpointConfigSummary) *ListEndpointConfigsOutput {\n\ts.EndpointConfigs = v\n\treturn s\n}", "output": "// SetEndpointConfigs sets the EndpointConfigs field's value."}

{"input": "Summarize the following code: function() {\n    var data   = {};\n\n    if (this.data && !isObject(this.data)) {\n      return this.data;\n    }\n\n    // TODO - don't do this yet until virt properties are checked\n    // var keys   = Object.keys(this);\n    var keys = Object.keys(this.data ? this.data : this);\n\n    for (var i = 0, n = keys.length; i < n; i++) {\n      var key = keys[i];\n\n      if (key in this.constructor.prototype || key.charCodeAt(0) === 95) {\n        continue;\n      }\n\n      data[key] = this[key];\n    }\n\n    return data;\n  }", "output": "serialize this model back into a data object"}

(submodlib) [babangain@cccxc406 submodlib]$ 